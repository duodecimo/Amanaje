#!/usr/bin/env python
# by duo July 2018

import tkinter
import cv2
import PIL.Image, PIL.ImageTk
import time
import pyscreenshot as ImageGrab
from tkinter.colorchooser import askcolor

class App:

    DEFAULT_PEN_SIZE = 5.0
    DEFAULT_COLOR = 'black'

    def __init__(self, window, window_title, video_source=-1):
        self.window = window
        self.video_source = video_source
        window.bind('<Escape>', lambda e: window.quit())
        self.window.title(window_title)
        self.screen_width = self.window.winfo_screenwidth()
        self.screen_height = self.window.winfo_screenheight() - 50

        # Create a canvas
        self.frame = tkinter.Frame()
        self.frame.pack(side = 'top', fill = 'both')
        self.canvas = tkinter.Canvas(window, bg='white', width = self.screen_width, height = self.screen_height)
        #self.canvas.grid(row=1, columnspan=7)
        self.canvas.pack()
        self.webcam_button = tkinter.Button(self.frame, text='webcam', command=self.toggle_webcam)
        self.webcam_button.pack(side="left", padx=4, pady=1)
        self.activate_webcam = True
        self.setup_paint()
        self.grab_canvas()
        self.window.mainloop()

    def snapshot(self):
        # Get a frame from the video source
        ret, frame = self.vid.get_frame()

        if ret:
            cv2.imwrite("frame-" + time.strftime("%d-%m-%Y-%H-%M-%S") + ".jpg", cv2.cvtColor(frame, cv2.COLOR_RGB2BGR))

    def update(self):
        # Get a frame from the video source
        ret, frame = self.vid.get_frame()

        if ret:
            self.photo = PIL.ImageTk.PhotoImage(image = PIL.Image.fromarray(frame))
            self.canvas.create_image(self.screen_width - (self.video_width+20), self.screen_height - (self.video_height+20), tags='cam_tag', image = self.photo, anchor = tkinter.NW)

        self.id_webcam = self.window.after(self.delay, self.update)

    def grab_canvas(self):
        #x=root.winfo_rootx()+widget.winfo_x()
        #y=root.winfo_rooty()+widget.winfo_y()
        #x1=x+widget.winfo_width()
        #y1=y+widget.winfo_height()
        filename = "/home/duo/extra/amanajeMovie/frame-" + time.strftime("%d-%m-%Y-%H-%M-%S") + ".png"
        im=ImageGrab.grab(bbox=(0,0,self.screen_width,self.screen_height))
        im.save(filename)
        self.cdelay = 24
        self.id_grab_canvas = self.window.after(self.cdelay, self.grab_canvas)

    def toggle_webcam(self):
        if self.activate_webcam:
            self.activate_webcam = not self.activate_webcam
            self.webcam_button.config(relief=tkinter.SUNKEN)
            self.video_width = 320
            self.video_height = 240
            # open video source (by default this will try to open the computer webcam)
            self.vid = MyVideoCapture(self.video_width, self.video_height, self.video_source)
            # After it is called once, the update method will be automatically called every delay milliseconds
            self.delay = 20
            self.update()
        else:
            self.activate_webcam = not self.activate_webcam
            self.webcam_button.config(relief=tkinter.RAISED)
            self.window.after_cancel(self.id_webcam)
            self.canvas.delete('cam_tag')
            del self.vid

    def setup_paint(self):


        self.pen_button = tkinter.Button(self.frame, text='pen', command=self.use_pen)
        self.pen_button.pack(side="left", padx=4, pady=1)

        self.brush_button = tkinter.Button(self.frame, text='brush', command=self.use_brush)
        self.brush_button.pack(side="left", padx=4, pady=1)

        self.color_button = tkinter.Button(self.frame, text='color', command=self.choose_color)
        self.color_button.pack(side="left", padx=4, pady=1)

        self.eraser_button = tkinter.Button(self.frame, text='eraser', command=self.use_eraser)
        self.eraser_button.pack(side="left", padx=4, pady=1)

        self.choose_size_button = tkinter.Scale(self.frame, from_=1, to=10, orient=tkinter.HORIZONTAL)
        self.choose_size_button.pack(side="left", padx=4, pady=1)

        self.snapshot_button = tkinter.Button(self.frame, text='snapshot', command=self.snapshot)
        self.snapshot_button.pack(side="left", padx=4, pady=1)

        self.old_x = None
        self.old_y = None
        self.line_width = self.choose_size_button.get()
        self.color = self.DEFAULT_COLOR
        self.eraser_on = False
        self.active_button = self.pen_button
        self.canvas.bind('<B1-Motion>', self.paint)
        self.canvas.bind('<ButtonRelease-1>', self.reset)

    def use_pen(self):
        self.activate_button(self.pen_button)

    def use_brush(self):
        self.activate_button(self.brush_button)

    def choose_color(self):
        self.eraser_on = False
        self.color = askcolor(color=self.color)[1]

    def use_eraser(self):
        self.activate_button(self.eraser_button, eraser_mode=True)

    def activate_button(self, some_button, eraser_mode=False):
        self.active_button.config(relief=tkinter.RAISED)
        some_button.config(relief=tkinter.SUNKEN)
        self.active_button = some_button
        self.eraser_on = eraser_mode

    def paint(self, event):
        self.line_width = self.choose_size_button.get()
        paint_color = 'white' if self.eraser_on else self.color
        if self.old_x and self.old_y:
            self.canvas.create_line(self.old_x, self.old_y, event.x, event.y,
                               width=self.line_width, fill=paint_color,
                               capstyle=tkinter.ROUND, smooth=tkinter.TRUE, splinesteps=36)
        self.old_x = event.x
        self.old_y = event.y

    def reset(self, event):
        self.old_x, self.old_y = None, None


class MyVideoCapture:
    def __init__(self, video_width, video_height, video_source=-1):
        # Open the video source
        self.vid = cv2.VideoCapture(video_source)
        if not self.vid.isOpened():
            raise ValueError("Unable to open video source", video_source)

        # Get video source width and height
        self.vid.set(cv2.CAP_PROP_FRAME_WIDTH, video_width)
        self.vid.set(cv2.CAP_PROP_FRAME_HEIGHT, video_height)

    def get_frame(self):
        if self.vid.isOpened():
            ret, frame = self.vid.read()
            if ret:
                # Return a boolean success flag and the current frame converted to BGR
                return (ret, cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
            else:
                return (ret, None)
        else:
            return (ret, None)

    # Release the video source when the object is destroyed
    def __del__(self):
        if self.vid.isOpened():
            self.vid.release()

# Create a window and pass it to the Application object
App(tkinter.Tk(), "Amanaj√©")
